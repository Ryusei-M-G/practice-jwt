# JsonWebTokenを使用した認証機能の練習
認証の流れを把握するために学習用として作成しました。
練習用のためDB接続のコードやキーなどはハードコードしています。
## 機能について
### 1. 登録
#### エンドポイント `/register`
- request bodyのデータをサーバーでチェックしDBに登録します。この際にbcryptでパスワードをハッシュ化して保存します
### 2. ログイン
#### エンドポイント `/login`
- request bodyのデータをDBのデータと照合して、一致していればトークンを返します。
- JSONレスポンスに期限1分のアクセストークンを返し、Cookieに期限7日のリフレッシュトークンを返します。
### 3. 認証が必要なプロフィール情報
#### エンドポイント `/profile`
- アクセストークンに含まれるユーザー情報に基づいたプロフィール情報を返します。
- アクセストークンの期限が切れていれば、リフレッシュトークンを認証してから新規でアクセストークンを発行します。
- アクセストークンの再発行後はリフレッシュトークンも再発行し新しいリフレッシュトークンを返します。
### 4. ログアウト
#### エンドポイント `/logout`
- CookieにあるRTを削除します。
  - 課題点
  - JWTの特性からRTが窃取されると期限中は使用される恐れがある。
  - ログアウト実行時にサーバー側でブラックリスト化して、認証時にはじくように設定する必要がある
### 5. リフレッシュ
#### エンドポイント `/refresh`
- ATでの認証に失敗した際にクライアント側からcookie情報を含めた通信でアクセスを行う
- CookieにあるRTを認証して、ATを返す
- クライアント側は最初のリクエストで401になった際に自動で`/refresh`にアクセスし、その後再度元のリクエストを実行する
- そのため、ユーザー側からはAT認証失敗時も通常通り動作しているように見える。
  - 課題
  - AT再発行後はRTも再発行し、元のRTはブラックリスト化する
  - 
## データベース設計

### テーブル関係

**users** ──(1:1)── **profile**

- usersテーブルとprofileテーブルは1対1の関係
- profile.user_id が users.id を参照する外部キー

### テーブル定義

#### users テーブル
- `id` (serial4) - Primary Key
- `email` (varchar(255)) - メールアドレス
- `username` (varchar(100)) - ユーザー名
- `password` (varchar(255)) - ハッシュ化されたパスワード
- `create_at` (timestamp) - 作成日時

#### profile テーブル
- `user_id` (int4) - Primary Key, Foreign Key (users.id)
- `text1` (text) - プロフィール情報1
- `text2` (text) - プロフィール情報2
